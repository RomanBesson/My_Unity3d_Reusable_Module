[toc]

# 面向对象六大原则

**分别为：**

①单一职责原则 

②开放封闭原则 

③依赖倒置原则

④里式转换原则 

⑤接口隔离原则 

⑥迪米特原则

## 1..单一职责原则

简单来说就是。一个类或者一个方法只负责一个功能。比如控制移动的方法别写到控制动画里。

## 2.开放封闭原则

**软件实体（类，方法，模块）应该可以扩展，但是不可以修改。**

意思就是，在添加和修改的时候，我们不要去修改原来的代码来达到，更应该是去写更多扩展方法去完成。

## 3.依赖倒置原则

**高层模块不应该依赖于底层模块，两个模块都应该依赖于抽象(抽象类/接口)。**

简单来说，就是高层类的扩展要尽量被约束于底层，比如约束于抽象类，接口。

## 4.里氏转换原则

**①一个软件实体如果使用的是一个父类的话，那么一定适用于其子类。而且它察觉不出父类对象和子类对象的区别。**

**②在软件里面，把父类都替换成它的子类，软件的行为没有变化；简单点说，子类型必须能够替换掉它们的父类型。**

这个就最常见于多态，子类可以继承父类的方法，可以转换成父类，以及父类的对象声名可以用子类实现。

**例如:**

小米品牌 mi = new 小米手机(); ① ②

小米手机 m5 = new 小米手机(); ②

小米手机 m4 = (小米手机)mi; ③



**①子类对象可以直接赋值给父类变量；**

理解：使用小米手机的用户就是小米公司的用户。

**②子类对象可以调用父类中的成员，但是父类对象永远只能调用自己的成员；**

理解：小米手机可以打电话，还能能使用小米公司的售后服务；但是小米公司不\能打电话，它只能折腾自己的用户体验，设计理念，品牌定位，营销策略...... 

**③如果父类对象中装的是子类对象，可以将这个父类对象强转为子类对象；**

## 5.迪米特原则

**这是一个降低耦合性的原则。**

①如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另外一个类的某一个方法的话，可以通过第三者转发这个调用。

②一个对象应当对其他对象有尽可能少的了解。

### 编程中的切入点

**①在类的结构设计上，每一个类都应当尽量降低成员的访问权限。**

Unity 项目开发，不要使用 public 公开字段，然后面板拖拽资源赋值这种方式。应该把字段全部 private 修饰，然后 public 属性公开调用。

**②迪米特原则主要是强调了类与类之间的松耦合。**

类与类之间的耦合度越低，越有利于代码的复用，一个处于低耦合的类被修改了，不会对有关系的类造成影响。

## 6.接口隔离原则

①客户端不应该依赖它不需要的接口；

②一个类对另一个类的依赖应该建立在最小的接口上。

# GOF23 种设计模式

## 1.创建型设计模式

### 1.简单工厂模式(静态工厂模式1)

**简单工厂模式[Simple Factory]，又叫做静态工厂模式。**

**简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。**

简单来说，就是创建对象的时候创建一个可以生成该类对象的工厂，由工厂来生成对应的对象。

**模式代码结构：**

抽象产品角色：简单工厂模式创建的所有对象的父类，用于描述类的公共部分；

具体产品角色：简单工厂模式创建出来的具体产品类；

简单工厂角色：简单工厂模式的核心，实现了创建产品的内部逻辑。

外部可以通过访问“简单工厂”就可以得到具体的产品，而不需要关注产品的具体创建过程。

#### 案例:坦克生成

我们需要生成不同种类的坦克。

**Uml如图：**

![简单工厂模式UML](../Img/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FUML.jpg)

### 2.工厂模式

简单工厂模式不符合“开发封闭原则”。

当我们需要增加新的产品的时候，需要对坦克工厂类中增加新的 case 语句块，

现在的坦克工厂类不够“封闭”，且产品量很多的时候，工厂类中的 case 语句块也会很多。(工厂类的代码过于耦合)

**所以，需要一个新的模式--工厂方法模式。**

工厂方法模式[Factory Method]，该模式定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

工厂方法模式是对简单工厂模式的进一步抽象和升级，但绝不是替代工厂方法模式[Factory Method]，该模式定义了一个用于创建对象的接口，让

子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

工厂方法模式是对简单工厂模式的进一步抽象和升级，但绝不是替代。

#### 模式代码结构

抽象产品角色：创建的所有对象的父类，用于描述类的公共部分；

具体产品角色：创建出来的具体产品类；

抽象工厂角色：工厂的抽象父类，定义生成产品的方法；

具体工厂角色：抽象工厂角色的具体子类，每一个具体产品都对应一个工厂。

**简单来说，就是在简单工厂模式的基础上，将工厂类进行进一步抽象，让对应的工厂类生产对应物品。**

#### 案例：生成坦克优化

图如下：

![工厂方法模式UML](../Img/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8FUML.jpg)

> **扩展理解：**
>
> ①工厂方法模式克服了简单工厂不符合“开放封闭原则”的缺点，又保持了对象创建过程的封装。
>
> ②缺点是增加了工作量，每增加一个子产品，就需要增加一个对应的工厂；另外case 的逻辑搬家到了客户端。



### 3.建造者模式

#### 1.模式介绍

**建造者模式[Builder]，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。**

建造者模式的意思是，使用一个建造的类在类本身对想要建造的物体进行建造。

#### 2.模式代码结构

**产品角色：**最终要创建出来的对象的类，本身也可以有父子继承关系；

**抽象建造角色：**定义对象的抽象建造步骤；

**具体建造角色：**继承抽象建造角色，完成对象建造步骤中具体的逻辑；

**指挥者角色：**建造者模式的核心，用于完成产品的最终建造

#### 案例：小怪生成

![建造者模式](../Img/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg)



## 2.结构型设计模式

### 1.装饰模式

#### 1.模式介绍

**装饰模式[Decorator]，动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。**

就是在装饰类里添加被装饰者的对象jin'xing

#### 2.模式代码结构

装饰类角色：装饰模式的核心，用于持有被装饰的角色；

被装饰角色：在当前案例中指的是 Player；

具体装饰角色：在当前案例中指的是“玩家称号”。

#### 案例：人物换装

### 2.组合模式

1.组合模式概念

**组合模式（Composite），将对象组合成树形结构，以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具备一致性。**

就是使用组合类同时实现多组相同类对象的接口，从而让他们组合在一起，便于管理。

### 3.外观模式

**外观模式（Facade）：为子系统中的一组接口提供一个一致的界面；此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。**

这个就是类似于使用管理类进行封装，让外界只能直接接触管理类。

### 4.适配器模式

#### 1.适配器模式概念

**适配器模式（Adapter）：将一个类的接口转换成客户希望的另外一个接口。该模式使得原来由于接口不兼容而不能一起工作的那些类可以一起工作。**

## 3.行为型设计模式

### 1.中介者模式

#### 1.模式介绍

**中介者模式（Mediator）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。**

简单来说，找了个中间商？

#### 2.模式代码结构

具体对象角色：需要交互的对象，两个以上，它们之间互相没有联系，但是都和中介者角色有联系；[见图]

具体中介者角色：需要知道所有需要交互的对象，并处理对象之间的交互。

### 2.职责链模式

#### 1.模式介绍

**职责链模式（Chain of Responsibility）:使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将接收者对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。**

简单来说，消息框架。

#### 2.模式代码结构

抽象父类角色:定义统一的抽象方法用于处理请求，以及存储下一个对象；

具体子类角色:每一个子类都需要继承抽象父类，实现父类中的处理请求的方法。



### 3.观察者模式

#### 1.基础介绍

**观察者模式【Observer】：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生改变时，会通知所有观察者对象，使他们能够自动更新自己。**

举个例子，多播委托。

### 4.策略模式

#### 1.模式介绍

策略模式（Strategy）：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的用户。

#### 2.模式代码结构

抽象策略父类：定义算法的公共接口；

具体策略子类：继承抽象父类，实现父类内的抽象方法，完成具体算法逻辑；

上下文角色：存储和持有当前状态下的算法。



### 5.模板方法模式

#### 1.模式介绍

**模板方法模式（Template Method）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。**

这个最常见，类就是用了这个。

#### 2.模式代码结构

抽象父类：其实就是抽象模板，用于定义算法的骨架结构；

具体子类：用于重新定义算法的细节部分。1.模式介绍

模板方法模式（Template Method）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。