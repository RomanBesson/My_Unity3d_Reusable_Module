[toc]

**90%的精力优化美术资源，10%的精力优化项目代码。**

# Stats 统计面板

## 1.Stats 面板顶点数与面数

### Tris 和 Verts

Tris：三角面数量；[Tris 是英文单词 Triangle 的复数缩写]

Verts：顶点数量；[Verts 是英文单词 Vertice 的复数缩写]

### 有关顶点数和面数的注意点

- 当前场景内肉眼可见的资源只有一个**天空盒**，将天空盒改为纯色渲染；
- Stats 面板上显示的三角形面数和顶点数并不是指的当前场景内所有元素的顶点数与面数的累计之和，而是**摄像机视锥体**观看到的范围内的所有元素的顶点数与面数的累计之和。
- Unity 内的 Cube 和在 3Dmax 里创建的 Cube，三角面数是一样的，都是 12个三角面；但是顶点数，Unity 却比 3Dmax 多了 3 倍；
- Unity 内的 Cube 模型“8 个肉眼可见的顶点”，其实每个顶点位置都重合了 3个顶点。

### 影响帧数的关键因素

帧数的英文单词缩写为 FPS。

- 如果只是纯粹的增加场景内顶点和面数，帧率下降的并不大，但是电脑硬件的性能消耗会变大。而且世界不可能只是一片漆黑，需要有光。
- 开启**灯光**，场景的帧率会从几百帧降低到 30 多帧，Tris 数量会增加到 40M左右，在没有开启灯光之前，场景内模型是 10M，也就是说灯光的开启导致 Tris数值增加了 30M。
- 灯光的加入，不单单是照亮了三维世界，而且还产生了**阴影**。全选场景内所有的 Cube 模型，将阴影全部关掉。Tris 数量会从 40M 左右降低到 20M左右，而游戏的帧率已经恢复到 90 帧左右；

增加出来的 30M 三角面，阴影占 20M，灯光占 10M。

### Stats 面板其他数据信息

#### Shadow Casters

**1.概念介绍**

Shadow 中文是阴影，这个属性肯定和光照是相关的，因为有光照才会产生阴影；Casters 中文是投射器。Shadow Casters 可以理解为“阴影投射器”。

Shadow Casters 属性用于统计在有光照的前提下且在摄像机的视锥体范围内，有多少游戏物体具备投射阴影的能力。

**该属性是一个偏“玄学”的属性，很多细微的操作都会改变它的数值，所以各位只需要大概的了解这个属性即可，没必要太在意数值的每一次的增加和减少。**

#### Batches

**1.概念介绍**

Batches 中文是“批次”“一批”。在场景内有一堆游戏物体，这一堆游戏物体都需要进行渲染，该属性表示渲染完这些游戏物体需要分多少次。

#### 优化 Batches 数值的方法

**[必须在编辑状态做如下操作]**

①在场景内创建一堆 Cube 模型，全选所有的 Cube 模型；

②Unity 界面右上角的 Static 下拉菜单选择 Batching Static“**静态批处理**”选项，然后运行项目；

③静态批处理可以将场景内相同的元素“打包到一块”进行处理，可以有效降低Batches 的数值。

>**批处理的注意点:**
>
>- 通过代码实例化生成的游戏物体，已经不具备静态批处理的效果了；
>- 前台生成的模型，在属性面板上依然还是显示静态批处理的设置状态；
>- 不能代码生成，也就意味着静态批处理我们必须在场景运行前进行模型资源的摆放，以及静态批处理属性的设置。
>- 设置了静态批处理属性的模型，Transform 组件控制无效。
>- 设置了静态批处理属性的模型，Rigidbody 组件控制无效。
>- 有动画的模型，设置静态批处理属性，不会降低 Batches 的数值，有动画的模型，即使设置了静态批处理，也跟没有设置是一样的。
>
>刚才的几个测试场景，都是不能使用静态批处理属性的场合，那么什么场合可以使用静态批处理呢？？
>
>①游戏场景内的“背景元素”，比如说：不需要改变位置，也不需要进行刚体交互的建筑物，路边的石头，树木等，这些“死”的游戏场景元素。
>
>②这些场景元素是在做搭建游戏场景的时候，就需要事先摆放好它们的位置，然后设置成静态批处理。

#### SetPass Calls

**1.概念介绍**

这个属性是和 Shader 着色器相关的，而 Shader 脚本文件是依附在材质球上起作用的。换言之，该属性和材质球文件有关。

Pass 是 Shader 代码中的一种语句代码块，类似于编写 C#代码时定义了函数语句块。

**Call 是调用执行的意思。该属性表示渲染过程中执行的 Pass 的数量。**

**同样材质球的物体数量增加，数值不会增加的，是因为当前的这一堆模型它们使用的是同一个材质球上的挂载的同一个 Shader 脚本中的同一个 Pass 语句块进行渲染的。**

在项目当中创建材质球，然后挂载到游戏物体上，该数值会继续增加；

另外跟刚才测试 Batches 属性一样，场景有无灯光，模型是否开启投影，都会影响该数值。

# Profiler 分析器

Profiler 分析器相对于Stats 统计面板做了更多详细的描述。

## 1.Profiler 面板介绍

### 菜单功能区

**Record**：开始记录，该按钮默认是按下状态，运行 Unity 就可以直接开始记录；

**Clear**：清空记录，按下按钮可以清空 Profiler 面板内所有数据；

**Clear On Play**：开始运行时清空记录，在第二次运行时先清空上一次的记录；

**Frame**：帧（当前所在的帧数/总帧数）；

左右按钮：可以向前/向后逐帧调整当前需要观看的帧的数据。



## 2.数据列表区概要

### 基础介绍

①Profiler 面板上的数据列表区，一共有 13 项具体的监测数据项，每一项都是由“左侧表头”+ “右侧数据时间轴”的形式组成的。

②其实这 13 项具体的监测数据项，每一项都可以称之为“Profiler”，这个单词的中文含义是“分析器”，这 13 项都是具体某个方面的分析器。

③13 个具体功能的 Profiler，构成了 Unity 引擎内的 Profiler 分析器面板。

④这 13 个分析器按照功能定位的不同，可以分成 6 组。

### 三大硬件分析器

**CPU Usage(中央处理器使用率)**，**GPU Usage(图形处理器使用率)**，**Memory(内存)**，这三个分析器是用来分析当前项目对 CPU，显卡，内存条这三个硬件的使用情况。

### 灯光与渲染分析器

**Rendering（渲染）**和 **Global Illumination（全局光照）**，这两个分析器可以说是把显卡的使用情况又细分成了两个更针对性的分析器。

### 两个流媒体资源分析器

**Audio（音频）和 Video（视频）**，这两个分析器用于分析音频和视频的性能消耗。

### 两个物理分析器

**Physics（物理引擎）和 Physics(2D)（物理引擎(2D)）**，这两个分析器用于分析所有物理相关组件的消耗。物理组件有 3D 和 2D 之分，所以有两个物理分析器。

### 两个网络分析器

**Network Messages（网络消息）和 Network Operations（网络运营）**。

**这两个是针对客户端与服务器之间数据交互检测的**



# 渲染优化

## 1.LODGroup 组件

### LOD 组件介绍

LOD 中文含义是“多层次细节”，在不使用 LOD 的时候，我们只需要制作一个模型，然后不管距离摄像机多远还是多近，都显示该模型。

如果使用了 LOD 技术，这个时候制作一个模型，我们就需要为同一个模型制作三个的模型，这三个模型的精度不同，由高到低。然后根据摄像机距离模型的远近，显示不同精度的模型。

LOD 组件的位置：**Component-->Rendering-->LOD Group。**

### LOD 组件使用

首先在场景内创建一个空游戏物体，挂载 LODGroup 组件；

LODGroup 组件最关键的属性就是一个 4 个分区的横轴，根据摄像机距离模型的远近，LOD 组件会自动切换不同精度的模型显示，当距离很远的时候，就会处于 Culled 状态，这个状态就是没有模型显示的隐藏状态；

设置成 LOD 组件的状态模型后，会自动成为挂载了 LOD 组件游戏物体的子物体，最后不要忘记重置所有 LOD 状态模型的 Transform 组件；

### 注意事项：

- 在 3D 项目开发过程中，碰撞体和刚体组件是经常会使用到的，对于应用了 LOD组件的模型，物理相关的组件挂载到 LOD 根游戏物体上即可。
- 不管 LOD 处于哪个状态，4 个游戏物体上挂载的 4 个脚本，都会执行。也就是说 LOD 控制的状态模型，并不是我们传统意义上的“隐藏游戏物体”，而是类似于 Layer 渲染层的概念。

### DLC: 可以降低顶点数网格的简易插件--Mesh Optimizer[网格优化器]

先把包导进去。

**使用方法：**

①将需要进行网格降面优化的模型**（必须有网格组件Mesh Filter 组件的）**拖拽到场景中；

②选中模型，**挂载 Optimize Mesh 脚本**[网格优化器插件核心脚本]；

③Quality 质量滑块用于调整模型的面数；

④按下“Optimize Mesh!”按钮，会按上方滑块的数值进行网格优化，在按下的同时我们可以在 Scene 场景通过线框模式观看到降面后的效果；

⑤按下“Save Mesh!”按钮，将优化后的网格进行存储；

⑥注意：网格优化后，保存的只是一个 Mesh 网格，想正常显示，还需要我们手动指定材质球。

## 2.MipMap 贴图

### 概念介绍

①MipMap 贴图类似于 LOD，LOD 是对模型进行分层，MipMap 是对贴图进行分层。最终都是根据距离摄像机的远近，切换不同资源进行渲染显示。

②**所有导入unity内的图片资源，Unity引擎默认就会将该图片处理成MipMap格式**，也就是说，会针对当前的图片，生成一堆由大到小的图片。

### LOD 与 MipMap

①这两项技术的存在，都是为了优化渲染，降低硬件渲染的压力。但是这两项技术并不是凭空优化，它是拿内存消耗换渲染优化。

②无论是 LOD 还是 MipMap，当你使用了它们，同一个资源都必须有精度不同的多份资源加载到内存中。

③之前 LOD 注意事项已经说了，国内很多上帝视角的游戏，摄像机跟模型之间的距离几乎不会发生改变，这类项目就不要使用 LOD 技术；同样的道理，Unity默认将图片全部设置成了 MipMap 格式，这个内存开销我们可以直接优化掉，用不着 LOD 的场景，同样用不着 MipMap。

## 3.遮挡剔除相关组件

### 概念介绍

“遮挡剔除”我们可以直接通过字面意思去理解：

“遮挡”指的是在摄像机的视野内，前面有一个大模型挡住了后面的模型；

“剔除”指的是将摄像机内看不到的模型，即使它们在视锥体内，只要看不到，就将它们从渲染通道里面剔除掉，不进行渲染。



### 组件介绍

遮挡剔除解决方案由三部分组成：两个组件 + 两个静态标签 + 一个窗口面板。

<1>Occlusion Area：遮挡区域组件；

<2>Occlusion Portal：遮挡入口组件；

<3>Occluder Static：遮挡物静态；

<4>Occludee Static：被遮挡物静态；

<5>Occlusion Culling：遮挡剔除窗口面板。

### 遮挡区域组件[Occlusion Area]

操作步骤：

①创建一个空的游戏物体，挂载 Occlusion Area 组件；

②该组件可以调整位置[Center 属性]，可以调整大小范围[Size 属性]，通过调整大小，将需要启用遮挡剔除的场景区域包裹起来。

组件用途：

定义一个正方体区域，当摄像机进入该区域以后，就会进行遮挡剔除的相关运算。

### 两个静态标签

选中场景内需要参与遮挡剔除的所有模型资源，然后勾选 Occluder Static 和Occludee Static 两个标签。

**标签用途：**

**Occluder Static**：遮挡物 静态；[场景内巨大的墙壁模型]

**Occludee Static**：被遮挡物 静态；[墙壁后面的一大堆球体模型]

之所有所有参与遮挡剔除的模型都设置这两个标签，目的是让这些游戏模型具备两种状态：可以遮挡别的模型，也可以被别的模型所遮挡。

### 遮挡剔除面板[Occlusion Culling]

**操作步骤：**

①Window-->Rendering-->Occlusion Culling，打开窗口面板；

②直接点击窗口面板最下方的 Bake 按钮进行遮挡剔除相关的烘焙处理；

③将 Scene 视图右下角的“遮挡剔除面板”设置为 Visualize[可视化]类型；

④打开 Profiler 面板，运行项目，动态的改变摄像机的位置。

**面板用途：**

对遮挡剔除相关的组件，设置了相关标签的模型，进行“预烘焙”操作；以及可以直观的观看到遮挡剔除的效果。

### 注意事项:

- 当我们使用了遮挡剔除系统以后，会自动根据当前的场景名称生成一个同名的文件夹，里面就存放了遮挡剔除的相关数据。
- 如果场景内使用了遮挡剔除，每次调整完模型都需要重新烘焙一次数据。
- Unity 引擎默认渲染状态就是视锥体剔除，也就是说：在摄像机视锥体以外的场景元素模型，不进行渲染，从而提高渲染效率，加上了上面的操作只是锦上添花，而不是无中生有。

# 光照的优化

## 1.光照系统概要

Unity 引擎内光照系统的全称是“Global Illumination”，全局光照，简称为GI。全局光照有三种类型：**Realtime[实时]，Mixed[混合]，Baked[烘焙]。**

如果Unity 引擎界面的右下角“Auto Generate Lighting Off”自动生成光照是关闭的。现在往场景内添加模型，这些模型的光照信息将不会自动运算，虽然也有光照效果，但是光照运算并未完成。

**有两种方式可以打开全局光照设置面板：**

1. Window-->Rendering-->Lighting Settings；
2. 鼠标点击 Unity 界面右下角的“Auto .... Off”文字区域。

右下角勾选“Auto Generate”复选框，在场景内新增加模型的时候，就会自动计算生成新模型的光照信息。



## 2.光照烘焙

> **Mesh Renderer 组件**
>
> 随意选中场景内的一个模型，观察 Mesh Renderer 组件，该组件用于模型的渲染显示，默认有四个属性分组：
>
> **①Materials[材质]**：各位最熟悉的一组，用于挂载模型需要使用的材质球；
>
> **②Lighting[光照]**：阴影的开与关，以及当前模型是否接收投影；
>
> **③Probes[探头]**：灯光探头和反射探头的相关设置；
>
> **④Additional Settings**[附加设置]：不需要进行设置，忽略。

> **灯光面板属性设置**
>
> **面板功能概要**
>
> 在灯光组件上我们可以设置灯光的模式：实时，混合以及烘焙；但是灯光组件只是初步设置，还需要在 Light 面板上对灯光模式的详细参数进行配置和预计算。
>
> **六个属性分区**
>
> ①**Environment**：环境光源设置，包含天空盒，反射相关的设置；
>
> ②**Realtime Lighting**：对应 Light 组件 Mode 模式中的 Realtime；
>
> ③**Mixed Lighting**：对应 Light 组件 Mode 模式中的 Mixed；
>
> ④**Lightmapping** **Settings**：对应 Light 组件 Mode 模式中的 Baked；
>
> ⑤**Other** **Settings**：其他效果设置，包含雾效，光晕，剪影等效果的设置；
>
> ⑥**Debug** **Settings**：调试设置，用于辅助场景光照效果的调试。

### 操作步骤：

1. 是首先需要关闭光照面板的“Auto Generate”，如果它是开启状态，在我们将当前场景的光照类型切换成“烘焙光照”的过程中，会一直进行“半成品”烘焙，属于无效运算。正常做法是先关闭，当我们将所有的相关信息设置完毕以后，再手动点击这个按钮一次性生成最终的光照贴图。
2. Lighting 分组中有一个 Contribute Global Illumination 的复选框，默认是未选中状态。要进行“光照烘焙”，该属性必须勾选，等同于右上角 Static 设置为 Contribute GI（修改物体上的也行）。（**该属性复选框勾选上以后，Mesh Renderer 面板会出现一个新的属性分组：Lightmapping**）
3. 在灯光组件上，调整Mode现在我们需要进行光照烘焙，所以模式切换为 Baked。
4. 在 Lighting 面板上进行光照烘焙，第一步就需要关闭 Realtime Lighting 属性分区的复选框，关闭实时 GI 的运算。
5. 当关闭实时 GI 以后，下方的 Lightmapping Settings 保持默认的参数，其实现在已经可以开始烘焙光照贴图了，直接点击下方的“Generate Lighting”。

### 优化光照烘焙

#### **Lightting面板调整光照烘焙参数**

**1.光照贴图烘焙系统[Lightmapper]**

该参数有三种烘焙系统可供选择：

①**Enlighten(Deprecated)**，，在当前版本已经标示为“弃用”，后续 unity 版本会被直接移除。

②**Progressive CPU**，当前版本默认选用的烘焙系统；

③**Progressive GPU(Perview)**，后续的新版系统，目前还是“预览版”。

**2.光照贴图清晰度[Lightmap Resolution]**

该参数默认值为 40；调高该参数可以提高光照贴图的清晰度，与此同时需要消耗更多的烘焙时间，以及生成更大的光照贴图。

开发阶段，为了快速测试场景的烘焙效果，可以将该参数调整为 20，甚至 10，当项目最终发布之前，可以调高到 50，甚至 70，进行最终效果的烘焙。

**3.光照贴图尺寸[Lightmap Size]**

该参数默认值为 1024；1024 指的是生成的光照贴图尺寸的上限。

如果生成的光照贴图清晰度很低，它会自动生成 512 甚至 256 尺寸的贴图；

如果生成的光照贴图清晰度很高，它会生成多组 1024 尺寸的贴图。

**4.压缩光照贴图[Compress Lightmaps]**

该参数默认是勾选状态；会对生成的光照贴图自动压缩，以降低光照贴图占用的存储空间。

**5.环境光闭塞[Ambient Occlusion]**

该参数默认是未勾选状态；建议勾选，开启 AO 效果可以让场景模型的暗面和阴影部分的画面效果更丰富，而且不会增加光照贴图的烘焙时长和贴图尺寸。

### 探头组组件

烘焙模式存在一个问题，就是无法为动态的角色生成明暗变化效果，此时就需要探头组组件。

#### 组件介绍

主要用于使用了光照贴图的场景，可以通过探头提取所在空间位置的颜色信息，

当移动的角色模型进入该空间时，对角色产生“光照效果的影响”。

组件位置：**Component-->Rendering-->Light Probe Group。**

#### 使用步骤

1. 在场景资源面板右键-->Light-->Light Probe Group；这个组件上我们只需要点击一下“编辑”按钮，然后在场景就可以通过鼠标拖拽来控制“探头”的位置；当需要创建新的探头时，我们可以选中现有的探头，然后按 Ctrl + D 进行复制，然后拖拽到目标位置；
2. 探头可以使用鼠标单击单个选中，也可以按住鼠标左键进行框选；**（探头的摆放原则：光线变化丰富的地方，要摆放的稠密，光线变化少的地方，要摆放的稀松。）**

### 模型底部圆形阴影--Projector 组件

在烘焙模式下，场景内位置固定不变的模型可以使用光照贴图来模拟光照和阴影；场景内动态可移动的角色模型的光照效果可以通过灯光探头组来实现；

但是场景内没有实时光源，可移动的动态角色的阴影应该如何实现呢？？

使用Projector 组件。

#### 操作步骤

- 将 PBR 贴图格式的机器人拖拽到场景中，并且调整缩放尺寸；

- 修改颜色空间（Color Space）由 Gamma 切换成 Linear；**File->BuildSettings->PlayerSettings->OtherSettings->Color Space**（非必要。为了让画面更亮）

- 在场景内创建一个空游戏物体，挂载 Projector 组件；

- 素材资源导入，两张图片一个 Shader，创建 Projector 组件使用的材质球；

- 阴影贴图的 Warp Mode 属性需要修改为 Clamp 模式。

- 首先调整 Projector 的位置，投影器要位于角色模型的正上方；

- Projector 组件类似于摄像机，我们可以通过组件的近裁剪面，远裁剪面，以及 FOV 值，来调整阴影的大小；

  > 注意： 
  >
  > 由于 Projector 组件是由角色上方往下“投射”阴影，角色的身体部分也会有阴影的投射，所以需要用层的概念来避开角色身体部分；
  >
  > 如果角色有上跳的动作，阴影也会有大小变化，如果不想让投影发生大小变化，可以将 Projector 组件切换成正交模式；
  >
  > 当角色靠近周围的环境模型时，阴影也可能会产生“误投射”，修复方法依然是将这些模型放到一个层，然后 Projector 组件忽略该层。

  

## 3.混合光照

### 概念介绍

混合光照是介于实时光照和烘焙光照之间的一种光照模式。

**实时光照**：光照和阴影实时运算，但是性能消耗很大；

**烘焙光照**：光照和阴影以光照贴图的形式体现，但是对于动态角色不友好；

**混合光照**：针对场景内不动的环境模型，依然是生成光照贴图；但是对于动态的角色模型，使用实时光照，可以让动态角色模型具备更好的阴影效果。

### 操作步骤

①场景内不动的环境模型依然需要设置“GI 标签”；

②灯光组件的模式需要修改为 Mixed；

③Lighting 面板的设置跟烘焙光照时，使用同样的设置方案。

### 相关设置

#### Lighting Mode

当使用混合光照模式时，Mixed Lighting 属性区域的 Lighting Mode 需要进行相关设置。Lighting Mode 有三种设置项：

**①Shadowmask[阴影遮罩]**

<1>该模式可以产生光照贴图，但是场景内效果和实时光照模式，几乎没有任何区别。依然需要灯光组件来对所有的模型进行光照和阴影效果的实时运算。

<2>这个模式产生的贴图是“阴影遮罩”，当我们隐藏灯光组件以后，移动开参与光照烘焙的模型以后，在模型的下方，能看到阴影遮罩光照贴图的效果。但是这种效果不是我们所需要的。

**②Baked Indirect[间接烘焙]**

效果跟 Shadowmask 模式几乎一样，同样不是我们所需要的效果。

**③Subtractive**

这种模式可以满足我们的需求，静态不动的模型使用光照贴图，动态的模型使用光源动态产生光照和阴影。

#### 灯光组件阴影属性

之所以使用混合光照，就是因为动态角色模型能有更好的阴影效果，将灯光组件上设置为混合光照模式以后，我们需要设置“实时阴影”相关的属性：

**Strength[强度]**：阴影颜色的深度；

**Resolution[质量]**：阴影的质量；

**Bias[偏移]**：可以调整阴影和角色模型之间的距离；

**Normal Bias[法线偏移]**：调整该参数，可以避免角色身体投影的“漏光”。

## 4.实时光照

### 概念介绍

将灯光模式改为实时，场景内所有模型取消“GI 标签”，然后将 Lighting 面板上烘焙光照的复选框取消，只保留实时光照的设置。

### 优化操作

如果当前的场景必须要使用实时光照，能做的优化只有一个：

将场景内不需要移动位置的环境模型，设置为“静态批次”，用于降低场景渲染过程中的 Batches 的数值。

# 渲染管线

## 1.LWRP渲染管线（Lightweight RP）

这是一个相对于原来默认的渲染管线更加轻量化的渲染管线。

### LWRP 安装与配置

#### LWRP 安装

打开 PackageManager 面板，在 All packages 列表中找到 LWRP 扩展包，目前扩展包的名称和版本号分别是：Lightweight RP 6.9.2。

#### LWRP 配置

第一步：创建 LWRP Asset 文件

**Project 面板 Assets 文件夹内 --> Create --> Rendering -->Lightweight Render Pipeline --> Pipeline Asset**

第二步：切换渲染管线

**Edit --> Project Settings... --> Graphics --> SRP Settings**

场景内所有模型的材质都会丢失，变为粉红色。这是因为之前我们的项目使用的是内置渲染管线相关的 Shader，现在切换成 LWRP 管线，原有 Shader 无法识别。

第三步：切换 Shader

①我们可以选中模型，手动将原有的标准着色器切换成 LWRP 分组中的 Lit。

②也可以通过菜单的方式批量转换 Shader：**Edit --> Render Pipeline --> LWRP --> UpGrade.....**

# 打包部分

## 1.IL2CPP

脱离了虚拟机，把IL中间语言翻译成c++运行的方式。

# UI优化

## 1.Sprite Packer图集工具

### 启用 Sprite Packer

Edit --> Project Settings --> Editor --> Sprite Packer

该工具只有一个 Mode 属性，有五种属性状态，目前我们先关注前三种状态：

- **Disabled** [禁用模式，Unity 引擎默认就是当前状态]
- **Enabled For Builds**（Legacy Sprite Packer）[在打包时启用,旧版工具]
- **Always Enabled**(Legacy Sprite Packer)[一直启用,旧版工具]



**将 Mode 的模式由 Disabled 切换为 Always Enabled。**

选中项目工程内任何一张类型为“Sprite(2D and UI)”类型的图片，在Sprite Mode 模式下方会看到一个叫做 Packing Tag 的属性，当 SpritePacker 的 Mode 属性为 Disabled 的时候，该属性不可见。

Packing Tag 属性可以理解为图集名，将一堆图片设置为同一个 Tag，就会将这一堆图片打包成一个图集。

> <1>带有透明通道的图片，和不带透明通道的图片，即使 Packing Tag 设置为同一个名称，也会被分开打包成两个图集；
>
> <2>放在 Resources 文件夹下的 UI 图片无法打包成图集。