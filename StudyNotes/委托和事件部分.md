# 委托和事件

## 1.委托

### 1.1.基本介绍和使用

委托是一种可以把方法当做(方法的)参数来传递的函数形式，使用修饰符`delegate`修饰。类似于把这个方法交给委托代理执行。

**用法如下：**

```csharp
public delegate void CalcDelegate(int a, int b);
```

委托要和要绑定的方法的**返回值类型**，以及**参数列表**的类型保持一致。

**示例如下：**

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public delegate int AndroidDelegate(string name);
public delegate string IOSDelegate(int price);


public class Phone : MonoBehaviour {

	void Start () {

        MyAndroid("华为", Android6);

        MyIOS(7890, IOS5);

        
    }

    private void MyAndroid(string name, AndroidDelegate ad)
    {
        ad(name);
    }

    private void MyIOS(int price, IOSDelegate ios)
    {
        string temp = ios(price);
        Debug.Log(temp);
    }


    private int Android6(string name)
    {
        Debug.Log("Android6版本的手机" + name);
        return 6;
    }


    private string IOS5(int price)
    {
        return "IOS5手机的价格是" + price;
    }


}

```

### 1.2.多播委托

实际上，同参数同返回值的委托对象是可以绑定多个参数的，并且可以让绑定的函数按照添加顺序调用，这就是多播委托。

多播委托对象使用 `=`来初始化， `+=` 来添加方法， `-=` 来减少方法。

**示例：**

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;


public delegate void WebInfoDelegate();

/// <summary>
/// 多播委托.
/// </summary>
public class WebInfo : MonoBehaviour {

	void Start () {

        //添加方法
        WebInfoDelegate webInfoDel;
        webInfoDel = MKCode;
        webInfoDel += Taobao;
        webInfoDel += YouKu;
        webInfoDel += Baidu;

        //删除方法
        //webInfoDel -= Taobao;

        webInfoDel();
    }


    private void Baidu()
    {
        Debug.Log("www.baidu.com");
    }

    private void Taobao()
    {
        Debug.Log("www.taobao.com");
    }

    private void YouKu()
    {
        Debug.Log("www.youku.com");
    }

    private void MKCode()
    {
        Debug.Log("www.mkcode.net");
    }
}

```

#### DLC：多播存在的问题

如果，多播不只是存在于一个类里，而是多个类调用的话，就会出现重复初始化的问题，导致数据丢失。

- 主委托方法

  ```csharp
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
     //委托
  public delegate void EatDelegate();
  
  public class Master : MonoBehaviour {
  
      //单例
      public static Master Instance;
  
      void Awake()
      {
          Instance = this;
      }
  
  	void Update () {
  		if(Input.GetKeyDown(KeyCode.Space))
          {
              ChiFan();
          }
  	}
  
      private void ChiFan()
      {
          Debug.Log("吃饭时间到!!都过来吃饭~~");
          //调用委托
          EatDelegate();
      }
  }
  
  ```

- 委托的调用的方法类

  ```csharp
  using System.Collections;
  using System.Collections.Generic;
  using UnityEngine;
  
  public class Cat : MonoBehaviour {
  
  	void Start () {
          //添加进委托
          Master.Instance.eatDelegate = CatEat;
  	}
  
  	private void CatEat()
      {
          Debug.Log("主人喊吃饭啦!!去吃饭,喵喵喵~~");
      }
  }
  
  ```

  

此时，我们会发现，在其他类使用`=`也是被允许的（也可以写`+=`），但是这样会存在安全性问题，如果多个委托接受类存在，就会导致委托对象一直被初始化，出现数据丢失问题。此时，我们需要只允许添加，只能使用`+=` 和 `-=`的形式委托。

事件由此诞生！
